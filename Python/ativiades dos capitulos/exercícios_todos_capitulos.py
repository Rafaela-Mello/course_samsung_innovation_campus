# -*- coding: utf-8 -*-
"""SIC - Python Tarefas

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rvVzNF_q87GtYSPZkxETnEJR03Zrabzn

# **CAPÍTULO 1**

## **Unidade 1: Primeiros Passos**

**Missão: Criação de um currículo**
"""

print ('--------------------')
print ('Oi! Deixe-me apresentar')
print ('Nome: Rafaela Laryssa Mello Neto')
print ('Idade: 18 anos')
print ('Faculdade: Tecnologia de Análise e Desenvolvimento de Sistemas ')
print ('Endereço: Campinas, São Paulo, Brasil')
print ('Local de Nascimento: Bauru, São Paulo, Brasil')
print ('--------------------')

"""**Q1: Faça um código com sete linhas de print() que funcionam para produzir um resultado como abaixo.**"""

print ("    *")
print ("   ***")
print ("  *****")
print ("*********")
print ("  *****")
print ("   ***")
print ("    *")

"""## **Unidade 2: Planejamento para programação**

**Q1: Expressar a maneira de encontrar o hotel em pseudocódigo usando os comandos de pseudocódigo dados abaixo.
"Vá direto para o oeste neste cruzamento". Você verá quatro edifícios. Quando vir os correios, vire à direita do outro lado da estação dos correios. Vá direto, e quando você ver um restaurante italiano, o terceiro edifício é o hotel que você está procurando".**

**Q2: Desenhe um fluxograma da fatoração dos números 18, 39, 63, 126, 792**

## **Unidade 3: Introdução aos tipos de dados numéricos e à operação aritmética**

**Missão: Exibir a circunferência e a área de um círculo**
"""

pi = 3.14
radius = float (input("Insira o raio: "))
circ = 2.0*pi*radius
area = pi*radius*radius

print ("Raio do circulo: ", radius)
print ("Circunferência: ", circ)
print ("Area: ", area)

"""**Q1: Use a função int para emitir o número 100 adicionando a string "50" e o número 50.  Além disso, use a função str para produzir o resultado da adição "5050".**"""

print (int ("50") + 50)
print (str ("50" * 2))

"""**Q2: Um caracter '1' e três '0' são dados. Use estes quatro para fazer o número 1000. Aqui, apenas operações de adição podem ser usadas entre strings, e a função int() pode ser usada apenas uma vez.**"""

print (int('1' + '0' + '0' + '0'))

"""**Q3: Fatorial n! é definido como n * (n-1) * (n-2) *...*2*1.  Encontre 5! e 10! usando o número inteiro e o operador *, imprimindo-os como abaixo**"""

cinco = 5 * 4 * 3 * 2 * 1
dez = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

print ("O fatorial de 5! é: ", cinco)
print ("O fatorial de 10! é: ", dez)

"""## **Unidade 4: Variáveis e inputs (valores de entrada)**

**Missão: Calculadora de IMC**
"""

name = input("Digite seu nome: ")
height_cm = int (input("Insira sua altura(cm): "))
height_m = height_cm / 100
wight = int (input("Insira o peso (kg): "))
imc = wight / (height_m ** 2)
print (name, "tem o IMC de: ", imc)

"""**Q1: Atribuir os valores 30, 60 às variáveis largura e altura, respectivamente. Escreva um programa que utilize estas duas variáveis para encontrar a área do retângulo, como mostrado abaixo.**"""

largura = 30
altura = 60

area = largura * altura
print ("A área do retângulo é: ", area)

"""**Q2: O Teorema de Pitágoras afirma que o quadrado da hipotenusa c para qualquer triângulo retângulo é igual ao quadrado da base a mais o quadrado da altura b. Escreva o código que calcula o comprimento da hipotenusa recebendo a base e a altura como números inteiros.**"""

a = int (input("Qual é a base: "))
b = int (input("Qual é a altura: "))

c = a**2 + b**2
hipotenusa = c**0.5

print ("O resultado da hipotenusa é: ", hipotenusa)

"""**Q3: Receber um valor de raio do usuário e imprimir a circunferência e a área de um círculo com este raio. Use a variável PI= 3,141592 para obter este valor.**"""

pi = 3.14
raio = float (input("Insira o raio: "))
circ = 2.0 * pi * raio
area = pi * raio * raio

print ("\nRaio do circulo: ", raio)
print ("Circunferência: ", circ)
print ("Área: ", area)

"""**Q4: Escreva um programa que exibe os valores ao quadrado de 2 a 6 em uma tabela como a seguir. Como mostrado abaixo, pode ser aumentado de 2 para 6, e n tem um valor 2. Insira o valor real para a peça correspondente a a elevado n, de modo que o resultado de saída da equação seja 2 elevado 2.**"""

n = 2

print ("a\t n\ta**n")
print ("2\t", n, "\t", 2**n)
print ("3\t", n, "\t", 3**n)
print ("4\t", n, "\t", 4**n)
print ("5\t", n, "\t", 5**n)
print ("6\t", n, "\t", 6**n)

"""## **Unidade 5: Operações lógicas e de comparação**

**Missão: Calculadora de Ano Bissexto**
"""

year = int(input("Inserir ano: "))
leap_year = (year % 4 == 0 and year % 100 != 0) or year % 400 == 0
print (leap_year)

"""**Q1: Escreva o código que recebe o valor n através da entrada do teclado do usuário. Retornar True (Verdadeiro) se o número inteiro dado for ímpar e retornar False (Falso) se o número inteiro for par.  Para os casos em que n é 20 e 21, imprima o seguinte:**"""

number = int(input("Insira um número inteiro: "))
impar = (number % 2 != 0)
print ("O número inteiro é ímpar: ", impar)

"""**Q2: Escreva o código que recebe a entrada do usuário e determina se o valor inteiro n é um número par dentro da faixa de 0 a 100 ou não. O resultado da execução deve ser o seguinte:**"""

number = int(input("Insira um número inteiro: "))
par = (number % 2 == 0 and 0 < number < 100)
print ("A entrada é um número inteiro par entre 0 e 100: ", par)

"""**Q3: Receber um número inteiro de 3 dígitos do usuário. Se o centésimo dígito do inteiro n for 3, retorne True. Senão, retorne False.**"""

numero = int(input("Digite um número inteiro de três dígitos: "))
n1 = numero // 100

if n1 == 3:
  print ("True")
else:
  print ("False")

"""**Q4: Receber um número inteiro. Se o inteiro for um múltiplo de 5, retorne True. Senão, retorne False.**"""

number = int(input("Insira um número inteiro: "))
cinco = (number % 5 == 0)
print (cinco)

"""## **Unidade 6: Declaração Condicional 1**

**Missão: Gerador de loteria**
"""

n1,n2,n3 = 2,3,9
n = 0
a,b,c = input("Entre com um numero de três digitos separados por espaço:").split()
a = int(a)
b = int(b)
c = int(c)

if (a==n1) or (a==n2) or (a ==n3):
  n +=1
if (b==n1) or (b==n2) or (b ==n3):
  n +=1
if (c==n1) or (c==n2) or (c ==n3):
  n +=1
if (n ==3):
  print("Parabéns, você ganhou!")
if (n!=3):
  print("Sorry!")

"""**Q1: Se a pontuação de um usuário do jogo for superior a 1000 pontos, imprima 'Você é um(a) mestre(a)'.**"""

score = int(input("Insira sua pontuação: "))
print ("Sua pontuação:", score)
if score > 1000:
  print ("You're a master!")

"""**Q2: Escreva um programa que receba qualquer número inteiro x entre -100 e 100 e 1) imprime x na tela, e 2) imprime "...é um número natural" se x for um número inteiro maior que zero. Caso contrário, deixe-o simplesmente imprimir x como em x = -10.**"""

number = int(input("Insira um número inteiro: "))
print ("x =", number)
if number > 0:
  print (number, "é um número natural!")

"""**Q3: Escreva um programa que receba A idade como entrada e imprima "Adulto" se a idade for 20 anos ou mais, "Jovem" se tiver menos de 20 anos e for igual ou superior a 10, e "Criança" se tiver menos de 10 anos.**"""

idade = int(input("Insira sua idade: "))
if idade >= 20:
  print ("Adulto")
if idade < 20:
  print ("Criança")

"""**Q4: Escreva um programa que verifique a entrada em um brinquedo em um parque de diversões. O programa deve receber como entrada a idade e a altura e imprimir "Você pode entrar." caso a idade seja maior que 16 anos e a altura for maior que 150 cm, o programa deve imprimir "Você não tem permissão para entrar.", caso contrário.**"""

idade = int(input("Digite sua idade: "))
altura = int(input("Digite sua altura em cm: "))

if idade > 16 and altura > 150:
  print ("\nVocê pode entrar!")
else:
  print ("\nVocê não tem permissão para entrar!")

"""## **Unidade 7: Declaração Condicional 2**

**Missão: Jogo de cobrança de pênaltis**
"""

import random

n = random.randint(1,3) #gera numeros 1,2 ou 3
if n == 1:
  computer_choice ="esquerda" #computerChoice ou ComputerChoice
elif n==2:
  computer_choice = "centro"
else:
  computer_choice = "direita"

user_choice = input("Qual lado você atacará? (esquerda,centro,direita)")

if computer_choice == user_choice :
  print("Penalti perdido")
else:
  print("Marcou penalti!")

print("Posição de defesa do computador", computer_choice)

"""**Exercício de aplicação**"""

#Frutaria do David

print('#' * 50)
print("Frutaria de David")
print("Opções:")
print('1: Maçã (preço unitário: 5reais)')
print('2: Uva (preço unitário: 6 reais)')
print('3: Melão (preço unitário: 8 reais)')
print('4: Laranja (preço unitário: 2 reais)')
print('#' * 50)

valor_total = 0
pedido = int(input('Insira o código do produto (entre 1 e 4):'))
quantidade = int(input('Insira a quantidade de itens (entre 1 e 10):'))

if pedido == 1:
  fruta = 'maçã'
  preco = 5
elif pedido == 2:
  fruta = 'Uva'
  preco = 6
elif pedido == 3:
  fruta = 'Melão'
  preco = 8
else:
  fruta = 'Laranja'
  preco = 2

print('Fruta selecionada :', fruta)
print('Preço :', preco)
print('Quantidade :', quantidade)
print('Preço total é', preco * quantidade, 'reais')

dinheiro = int(input('Insira dinheiro por favor (ex: 15)'))
if dinheiro < preco * quantidade:
  print('Dinheiro insuficiente')
else:
  troco = dinheiro - preco * quantidade
  print(dinheiro, 'recebido. Seu troco é', troco, 'reais')

"""**Q1: Receber uma letra alfabética do usuário e imprimir 'É uma vogal' para a, e, i, o, u, e 'É uma consoante' para qualquer outra letra.**"""

letra = str(input("Digite uma letra do alfabeto: "))

if letra == 'a' or letra == 'A' or letra == 'e' or letra == 'E' or letra == 'i' or letra == 'I' or letra == 'o' or letra == 'O' or letra == 'u' or letra == 'U':
  print (letra, "é uma vogal")
else:
  print (letra, "é uma consoante")

"""**Q2: Escreva o seguinte programa que recebe dois inteiros a, b como entrada, determina se a é um múltiplo de b e imprime o resultado.**"""

num1 = int(input("Digite um número: "))
num2 = int(input("Digite um número: "))

if num1 % num2 == 0 or num2 % num1 == 0:
  print (num1, "é um múltiplo de", num2)
else:
  print (num1, "não é um múltiplo de", num2)

"""**Q3: Escreva um programa que executa adição, subtração, multiplicação e divisão. Ele imprime o resultado da operação de dois inteiros positivos, com base no número de operação desejado dado como entrada. Se um número diferente de 1, 2, 3 e 4 for dado como entrada, é impresso "Inserido um número incorreto". Para inserir dois números, escreva um, pressione enter e escreva outro.**"""

number = int(input("Selecione a operação desejada: \n1 - Adição\n2 - Subtração\n3 - Multiplicação\n4 - Divisão\nQual será: "))
if number != 1 and number != 2 and number != 3 and number != 4:
  print ("\nInserido um número incorreto. Tente novamente!")
else:
  num1 = int(input("\nDigite o primeiro número inteiro: "))
  num2 = int(input("Digite o segundo número inteiro: "))
  if number == 1:
    adicao = num1 + num2
    print ("\nAdição:", num1, "+", num2, "=", adicao)
  elif number == 2:
    sub = num1 - num2
    print ("\nSubtração: ", num1, "-", num2, "=", sub)
  elif number == 3:
    mult = num1 * num2
    print ("\nMultiplicação: ", num1, "*", num2, "=", mult)
  elif number == 4:
    div = num1 / num2
    print ("\nDivisão: ", num1, "/", num2, "=", div)
  else:
    print ("\nInserido um número incorreto. Tente novamente!")

"""**Q4: Escreva um programa que receba um ponto com coordenadas x e y como entrada, e determine em qual quadrante entre 1, 2, 3, 4 o ponto pertence. A posição do quadrante é mostrada na figura a seguir.**"""

x = int(input("Digite o número x: "))
y = int(input("Digite o número y: "))

if x > 0 and y > 0:
  print ("\nEstá localizado no primeiro quadrante!")
elif x < 0 and y > 0:
  print ("\nEstá localizado no segundo quadrante!")
elif x < 0 and y < 0:
  print ("\nEstá localizado no terceiro quadrante!")
elif x > 0 and y < 0:
  print ("\nEstá localizado no quarto quadrante!")
else:
  print ("\nInsira novamente dois números!")

"""**Q5: Desenvolver um programa de pedido de cardápio para o Restaurante Yummy. Mostre o seguinte menu ao usuário e deixe que o usuário selecione um. Se o alfabeto de entrada dado não estiver no menu, imprima 'entrar novamente no menu:' e receba outra entrada.**"""

escolha = str(input("Bem-vindo a um delicioso restaurante. Aqui está o cardápio.\nH - Hambúrguer\nF - Frango\nP - Pizza\nEscolha um menu (H, F ou P): "))

if escolha != 'H' and escolha != 'F' and escolha != 'P':
  print ("\nEntrar novamente no menu!")
else:
  if escolha == 'H':
    print ("\nSua escolha foi Hambúrguer!")
  elif escolha == 'F':
    print ("\nSua escolha foi Frango!")
  elif escolha == 'P':
    print ("\nSua escolha foi Pizza!")

"""## **Unidade 8: Loops 1**

**Missão: Lanchonete do David - Combinações para sanduíches**
"""

breads = ["centeio","integral","sem gluten"]
meats = ["vegana","peito de frango","peito de peru"]
vegis = ["alface","tomate","pepino"]
sauces = ["maionese","mostarda e mel","pimenta"]

print("Possiveis combinações de sanduiches do David:")
for b in breads:
  for m in meats:
    for v in vegis:
      for s in sauces:
        print(b,"+",m,"+",v,"+",s)

"""**Q1: Declarando a lista bts = ['V', 'J-Hope', 'RM', 'Jungkook', 'Jin', 'Jimin', 'Suga']. Em seguida, escreva um código que imprima todos os itens desta lista usando a declaração for.**"""

bts = ['V', 'J-Hope', 'RM', 'Jungkook', 'Jin', 'Jimin', 'Suga']
for i in bts:
  print (i)

"""**Q2: Use adição cumulativa para calcular e imprimir a soma de números inteiros de 1 a 100. (Dica: faça com que o valor impresso da função range varie de 1 a 100).**"""

print ("Soma de números inteiros de 1 a 100: ", sum(range(1,101)))

"""**Q3: Use o valor de etapa da função range para encontrar a soma dos números pares de 1 a 100. (Dica: Defina o valor inicial da função da faixa como zero e o valor do passo como dois).**"""

print ("Soma de números pares de 1 a 100: ", sum(range(0, 101, 2)))

"""**Q4: Use o valor de etapa da função range para encontrar a soma de números ímpares de 1 a 100. (Dica: Defina o valor inicial da função de intervalo para um e o valor do passo como dois)**"""

print ("Soma de números ímpares de 1 a 100: ", sum(range(1, 101, 2)))

"""**Q5: A Agência A está planejando a emissão de ingressos de uma sala de concertos para o show de cantores de ídolos. Aqui, o número n é a entrada e o número do assento é organizado da seguinte forma. n * n assentos são colocados quando n é dado como entrada. A disposição abaixo dos números dos assentos é chamada de matriz de serpente porque a matriz aumenta em uma matriz em forma de tronco de serpente. Escreva um programa que produza matrizes destes números.**"""

matriz = [[0]*n for _ in range(n)]
num = 1

n = int(input("Digite um número inteiro: "))

for i in range(n):
  if i % 2 == 0:
    for j in range(n):
      matriz[i][j] = num
      num += 1
  else:
    for j in range(n-1, -1, -1):
      matriz[i][j] = num
      num += 1

for linha in matriz:
  print(" ".join(map(str, linha)))

"""## **Unidade 9: Loops 2**

**Missão: O desafio do caracol em um poço**
"""

current_pos = 0
days = 1
move_up = 7
move_down = 5
destination =  30
current_pos += move_up

print("Dia:",days,"Posição do caracol:",current_pos, "metros")

while(current_pos <= destination):
  current_pos -=  move_down # é igual a current_pos = current_pos - move_down
  days += 1
  current_pos += move_up
  print("Dia:",days,"Posição do caracol:",current_pos, "metros")
print()
print("Levou {} dias para sair do poço".format(days))

"""**Q1: Escreva um programa que imprima a multiplicação de 2 usando a declaração while como segue.**"""

i = 1
while i <= 9:
  mult = i * 2
  print ("2 x ", i, " = ", mult)
  i += 1

"""**Q2: Vamos modificar o programa acima para imprimir todas as etapas de 1 a 9 da tabela de multiplicação. Use apenas a declaração while.**"""

n = int(input("Digite um número inteiro: "))
i = 1
while i <= 9:
  mult = i * n
  print (n, "*", i, " = ", mult)
  i += 1

"""**Q3: Um número palíndromo refere-se a um número inteiro cujo valor é o mesmo que seu valor original, mesmo se listado de cabeça para baixo, como 121 ou 3443. Escreva o seguinte programa para determinar se o número é um número palíndromo ou não, recebendo o número n do usuário.**"""

answer = 'sim'
i = 1

while answer == 'sim':
  n = int(input('Digite o número: '))
  if n != 121 and 3443:
    print (n, "não é um número palíndromo!")
  else:
    print (n, "é um número palíndromo!")
  answer = input("\nQuer digitar outro número? (sim/não): ")
  print ("\n")
  i += 1

"""**Q4: O computador tem um número inteiro aleatório entre 1 e 100 como o valor de resposta correto, como a seguir. Quando o usuário apresenta a resposta correta, o programa apenas informa se o inteiro apresentado é maior ou menor em comparação com a resposta correta que ele armazenou. Este jogo é repetido até que o usuário responda corretamente.**"""

import random as rd
i = 1

print ("Adivinhe o número de 1 a 100!")
n = int(input("Digite um número: "))
num = rd.randrange(1, 101)

while n != num:
  if n > num:
    print ("Mais baixo!")
    i += 1
    n = int(input("\nDigite um número: "))
  elif n < num:
    print ("Mais alto!")
    i += 1
    n = int(input("\nDigite um número: "))

print ("\nParabéns! Tentativa total: ", i)

"""## **QUIZZ - CAPÍTULO 1**"""

# O código que imprime os valores numéricos de 1 a 3 usando a função print() é o mesmo que print(1+2+3).
# Com referência a este código, imprima os valores de 1 a 5 da seguinte forma.

print ('1 + 2 + 3 + 4 + 5')

# Escreva um programa que imprima a soma dos números ÍMPARES de 1 a 100.

n = 1
s = 0
while n <= 100:
  s = s + n
  n += 2
print('Soma de 1 a 100 é {}'.format(s))

# Escreva um programa que recebe um número inteiro positivo do usuário e diz se é um número par ou ímpar.

n = int(input("Digite um número inteiro positivo: "))
if n % 2 == 0:
  print (n, "é par")
else:
  print (n, "é ímpar")

# Escreva um código que imprima uma sequencia de caracteres '*' na primeira linha e '#' na segunda linha.

print (" #" * 8)
print ("Meu nome é Rafaela\n", "*" * 15, "\nCurso TADS no IFSP\n", "*" * 15)
print (" #" * 8)

# Escreva um programa que recebe 2 entradas do usuário: nome e endereço, depois imprima essas variáveis na tela.

name = str(input("Digite seu nome: "))
address = str(input("Digite seu endereço: "))

print ("\nNome: ", name, "\nEndereço: ", address)

# Usando os operadores lógicos "and", "or" e "not" escreva um programa que, dado x = 1 e y = 0, imprima os seguintes resultados:

y = 0
x = 1

print(y)
print(x)
print(bool(y))
print(bool (x))

# Escreva um programa que leia 2 entradas do usuário e as imprima do menor para o maior.

num = input("Insira dois números inteiros: ")
num1, num2 = num.split()

num1 = int(num1)
num2 = int(num2)

if num1 < num2:
  print("Os números inseridos em ordem crescente são: ", num1, num2)
else:
  print("Os números inseridos em ordem crescente são: ", num2, num1)

# Escreva um programa onde o usuário deve responder duas perguntas, se é maior de idade e se é casado, depois imprima o resultado.

age = int(input("Você é maior de idade? (digite 1 se sim, 0 se não): "))
married = int(input("Você é casado(a)? (digite 1 se sim, 0 se não): "))

if age == 1 and married == 1:
  print ("\nVocê é maior de idade e casado(a)!")
elif age == 1 and married == 0:
  print ("\nVocê é maior de idade e solteiro(a)!")
elif age == 0 and married == 1:
  print ("\nVocê é menor de idade e casado(a)!")
elif age == 0 and married == 0:
  print ("\nVocê é menor de idade e solteiro(a)!")

# Entre os números naturais positivos diferentes de 1, um número que não é primo é chamado de número composto.
# Imprima os números primos e compostos de 2 a 12.

for num in range(2, 13):
  if num == 2:
    print(num, "é primo")
  else:
    for i in range(2, num):
      if num % i == 0:
        print(num, "é composto")
        break
    else:
      print(num, "é primo")

# Um número Armstrong é um número inteiro de três dígitos que é igual à soma dos cubos de cada dígito.

for num in range(100, 1000):
  cen = num // 100
  dez = (num // 10) % 10
  uni = num % 10

  soma_cubos = cen**3 + dez**3 + uni**3

  if soma_cubos == num:
    print(num, "é um número de Armstrong!")

"""# **CAPÍTULO 2**

## **Unidade 10: Listas e Tuplas**

**Missão: Criação de um banco de dados pessoais**
"""

person1 = ['David Doe',20,1,180.0,100.0]
person2 = ['John Smith',25,1,179.0,70.0]
person3 = ['Jane Carter',22,0,169.0,60.0]
person4 = ['Peter Kelly',40,1,150.0,50.0]

person_list = person1+person2+person3+person4
n_persons = int(len(person_list)/4)
age_sum = 0.0
for age in person_list[1::5]:
  age_sum += age
average_age = float(age_sum)/n_persons
print("A idade média é:"+str(average_age))

"""**Q1: Crie uma lista prime_list que tenha números primos entre 2 e 10 como elementos. Em seguida, use a indexação da lista para o primeiro elemento da lista e imprima conforme mostrado abaixo.**"""

prime_list = [2, 3, 5, 7]
print('Primeiro elemento do prime_list: ', prime_list[0])

"""**Q2: Crie uma lista prime_list que tenha números primos entre 1 e 10 como elementos. Em seguida, use o método anexar para adicionar 11. Imprima os resultados antes e depois da adição, conforme mostrado abaixo.**"""

prime_list = [2, 3, 5, 7]
print("Números primos: ", prime_list)
prime_list.append(11)
print("Números primos após a adição: ", prime_list)

"""**Q3: Para lista1 e lista2, use o loop for aninhado para multiplicar cada elemento de lista1 e lista2 e, em seguida, imprima o resultado com o resultado da multiplicação do elemento.**"""

lista1 = [3, 4, 7]
lista2 = [2, 3, 4, 5, 6]

for i in lista1:
  for j in lista2:
    print(i, "*", j, "=", i*j)

"""**Q4: Há uma lista com as strings s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cddc', 'opq']. Escreva o código que devolve a string mais curta dessa lista. Não utilize a função min ou o método sort. Se houver várias strings mais curtas, imprima a primeira como a seguir.**"""

s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cddc', 'opq']
menor_string = s_list[0]

for s in s_list:
  if len(s) < len(menor_string):
    menor_string = s

print("A string mais curta é:", menor_string)

"""**Q5: Há uma lista com as strings s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cddc', 'opq']. Escreva o código que devolve a string mais longa dessa lista. Não utilize a função max ou o método sort.**"""

s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cddc', 'opq']
maior_string = s_list[0]

for s in s_list:
  if len(s) > len(maior_string):
    maior_string = s

print("A maior string é:", maior_string)

"""**Q6: Há uma lista com as strings s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cddc', 'opq']. Na lista, as menores strings ('abc', 'bcd' e 'opq') têm o mesmo tamanho, 3. Escreva o código que imprime todas as strings com o menor comprimento na lista como no exemplo abaixo. Use o método sort para ordenar a lista.**"""

s_list = ['abc', 'bcd', 'bcdefg', 'abba', 'cdde', 'opq']

menor = min(len(s) for s in s_list)
menores_strings = [s for s in s_list if len(s) == menor]
# menores_strings.sort()

print("As strings mais curtas:", menores_strings)

"""## **Unidade 11: Dicionários**

**Missão: Criando um programa de cardápio**
"""

print("CAFETERIA SIC")
print("MENU")
menu ={'Americano': 3000,'Ice Americano':3500,'Capuccino':4000,'Cafe Late':4500,'Espresso':3600}
for key in menu:
    print('{:16s} preço:{:,}KRW'.format(key,menu[key]))
print()
choice = input("Selecione um item do menu: ")
if choice in menu.keys():
  print("O valor de um café {} é {:,}KRW".format(choice, menu[choice]))
  print("Realize o pagamento")
else:
  print("Desculpe. {} não está no menu".format(choice))

"""**Q1: Crie o dicionário "frutas_dic" que consiste em pares valor:chave contendo ("maçã", 6000), ("melão", 3000), ("banana", 5000), ("laranja", 4000). Em seguida, imprima todas as chaves do dicionário de frutas no formato de lista e examine se as chaves 'maçã' e 'manga' são encontradas no dicionário de frutas, como a seguir:**"""

frutas_dic = {'maçã':6000, 'melão':3000, 'banana':5000, 'laranja':4000}

for key in frutas_dic:
  print('{:10s} {:,} KRW'.format(key,frutas_dic[key]))
print()

choice = input("Selecione um item: ")
if choice in frutas_dic.keys():
  print("{} pertence a frutas_dic".format(choice))
else:
  print("{} não pertence a frutas_dic".format(choice))

"""## **Unidade 12: Sequências...**

**Missão: Calculadora de porcentagem de envelhecimento**
"""

pop_a = (100,150,230,120,180,100,140,95,81,21,4)
pop_b=(300,420,530,420,400,300,40,5,1,1,1)
old_a = sum(pop_a[7:])
old_b = sum(pop_b[7:])
sumA, sumB = sum(pop_a), sum(pop_b)
oldRateA, oldRateB = old_a/sumA, old_b/sumB
print('Os graus de envelhecimento nas cidades A e B são {:5.3f} e {:5.3f}, respectivamente.'.format(oldRateA, oldRateB))

"""**Q1: Preveja o resultado da execução do código a seguir e forneça o resultado manuscrito.**"""

t1 = 'a', 'b', 'c'
t2 = ('a', 'b', 'c')
t3 = ('d', 'e')

print(t1==t2)
print(t1>t3)
print(t1<t3)
print(t2+t3)
print([t2+t3])
print(t1)

"""**Q2: seguinte tuple registra as vendas diárias de uma loja por 10 dias. Escreva um código para imprimir quantos dias tinham reduzido as vendas em relação ao dia anterior. (Dica: compare os valores iterando os elementos com a declaração de iteração).**"""

tup = (100, 121, 120, 130, 140, 120, 122, 123, 190, 125)

reducao = 0
for i in range(1, len(tup)):
  if tup[i] < tup[i-1]:
    reducao += 1

print("Nos últimos 10 dias {} dias tiveram vendas reduzidas em relação ao dia anterior. ".format(reducao))

"""**Q3: Para uma dada tupla com números inteiros, devolva o elemento que ocorre o maior número de vezes. Caso existam mais de um elemento com o maior número de ocorrências, devolva o que seja de maior valor.**"""

# REVISAR ESSE EXERCÍCIO
tup =  (1, 2, 5, 4, 3, 2, 1, 4, 7, 8, 9, 9, 3, 7, 3, 9)
freq = {}
for x in tup:
  if x in freq:
    freq[x] += 1
  else:
    freq[x] = 1

max_freq = max(freq.values())
mais_frequentes = [k for k, v in freq.items() if v == max_freq]

print(mais_frequentes)

"""**Q4: Na saída abaixo, há tuplas que contém elementos e também tuplas sem elementos: tuplas vazias, strings vazias e listas vazias. Escreva o código que remove todas as tuplas, strings e listas vazias da lista dada a seguir. No entanto, não remova a tupla ((),), que não é considerada vazia por conter um elemento, que é uma tupla vazia.**"""

# seila aaaaaaaaa

"""## **Unidade 13: Listas 2D - FAZER**

**Missão: Sistema de reserva de assentos em salas de cinema**
"""

import random
seat =[]

for i in range(3):
  line =[]
  for j in range(6):
    rand = random.randrange(0,2)#Use os numeros aleatórios 0 e 1
    line.append(rand)
  seat.append(line)

avaliable =0
for i in range(3):
  for j in range(6):
    print(seat[i][j],' ',end=' ')
    if seat[i][j]==0:
      avaliable +=1
  print()
print("O numero de assentos disponiveis é:",avaliable)

"""**Q1: Escreva um programa que gera uma matriz multidimensional de tamanho n×n, com base no número informado pelo usuário, com n >= 2. Neste caso, o conteúdo que deve ser exibido é o arranjo de valores 0 e 1 posicionados em padrão quadriculado.**"""



"""## **Unidade 14: Métodos de Dicionários 1 - FAZER**

**Missão: Programa de cardápio de um café**
"""

print("Iniciar programa de cardápio do café... Pressione 'q' para sair")
cafe_menu = {'Café gelado' : 3000}

while True:
    str = input('$ ')
    if str.startswith('q'):
        break;
    command = str[0]

    if command == '<':
        str = str.replace('<', "")
        inputStr = str.split(':')
        if len(inputStr) < 2 :
            print('input error')
            continue
        else:
            cafe_menu[inputStr[0].strip()] = inputStr[1].strip()

    elif command == '>':
        str = str.replace('>',"")
        inputStr = str.strip()
        if inputStr in cafe_menu:
            print(cafe_menu[inputStr])
        else:
            print('{} não está no cardápio.'.format(inputStr))
    elif command == 'q':
        break
    else:
        print('input error.')
print("Saindo do programa de cardápio do café.")

"""**Q1: Vamos criar um dicionário chamado person_dic com as seguintes informações de contato em seu telefone. Imprima essas informações usando o loop for para mostrar os resultados de saída abaixo.**"""



"""**Q2: Vamos escrever um programa que realize o gerenciamento de estoque em uma loja de conveniência. Para tanto, o estoque dos itens vendidos nas lojas de conveniência é armazenado no dicionário de itens conforme exemplo abaixo. Escreva um programa que receba o nome do item dos usuários e retorne o estoque do item. Suponha que seja uma loja de conveniência muito pequena e os itens tratados sejam os seguintes.**"""



"""**Q3: Vamos atualizar o programa para gerenciar o inventário de lojas de conveniência que resolvemos em codificação em papel. Em outras palavras, adicionar código para aumentar ou diminuir o estoque. Além disso, fazer menus simples, como consulta de inventário, armazenagem e expedição.**"""



"""## **Unidade 15: Métodos de Dicionários 2 - FAZER**

**Missão: Lista telefônica de restaurantes**
"""

tel_dir_dic={'chines':('010-1234-5678'),'japones':('010-2340-9786'), 'italiano':('010-3232-7788')}
print('numero anterior')
for key,value in tel_dir_dic.items():
  print(key+':',value)
  print('')
for key,value in tel_dir_dic.items():
  adr,review = input(key+' Favor escrever o endereço e avaliação de').split()
  update =(value,adr,review)
  tel_dir_dic[key]=update
print('numero atualizado')
for key,value in tel_dir_dic.items():
  print(key+':',value)

"""**Q1: A lista de estudantes_tuplos com túplos como elementos é como mostrado abaixo. Tuple, que é o elemento deste tuple consiste em um (número de identificação de estudante, nome, número de telefone). Usando isto, faça um dicionário para (número de identificação de estudante: nome) e imprima-o. Ao perguntar pelo número de identificação de estudante, certifique-se de que o número de identificação de estudante, nome e número de telefone estejam impressos como mostrado abaixo.**"""



"""## **Unidade 16: Conjuntos - FAZER**

**Missão: Calculadora de probabilidade para o Monopoly**
"""

#Calculadora de probabilidade para o Monopoly:

case_3times =set()

for i in range(1,7):
  for j in range(1,7):
    for k in range(1,7):
      case_3times.add((i,j,k))

total_cases = len(case_3times)
print('total de casos que podem ocorrer com o lançamento de trÊs dados:',total_cases,'casos')

for i in range(3,19):
  total_cases = len(case_3times)
  n_cases = 0
  for c in case_3times:
    if sum(c)>=i:
      n_cases +=1
  #print(n_cases)
  prob = n_cases*100/total_cases
  #print(prob)
  print("probabilidade de se obter um valor maior do que {:2d} é de {:6.2f}%".format(i,prob))

"""**Q1: Use a função set para gerar e imprimir o conjunto s1 da próxima lista lst.**"""



"""**Q2: Anote os resultados computacionais para os dois conjuntos a seguir. Encontre os resultados de 1) a 7).**"""



"""**Q3: Há uma lista minha_lista com tuplas (m, n) como elementos, como mostrado abaixo. Se houver tupla com valor (a,b)  sendo a, b os valores inseridos pelo usuário, imprimir 'Há (a, b) na posição X'. Se não há (a, b) mas há (b, a) imprimir 'Não há (a, b) mas há (b, a) na posição Y'. Se não houver (a, b) nem (b, a), imprima 'não há (a, b) nem (b, a)'.**"""



"""## **QUIZZ - CAPÍTULO 2**"""

# Escreva duas strings, s1 e s2, com o conteúdo "Eu amo", "Eu gosto de" e "Panqueca", "Suco de laranja", "Café" respectivamente.
s1 = ["Eu amo", "Eu gosto de"]
s2 = ["Panqueca", "Suco de laranja", "Café"]

for i in s1:
    for j in s2:
      print(i, j)

# O dicionário de pessoas é definido da seguinte forma: person = {'Name': 'Davi', 'Age': 26, 'Weight': 82, 'Job': 'Cientista de dados'}
# Adicione um novo item a este dicionário person com a chave 'Pai' e o valor 'Antônio' e imprima o dicionário.
person = {'Name': 'Davi', 'Age': 26, 'Weight': 82, 'Job': 'Cientista de dados'}
print(person)
person['Pai'] = "Antônio"
print(person)

# Usando este método de troca, escreva um programa que deixe o maior valor por último na lista.
list = [5, 6, 3, 9, 2, 12, 3, 8, 7]

for i in range(len(list) - 1):
  if list[i] > list[i+1]:
    list[i], list[i + 1] = list[i + 1], list[i]
print(list)

# Mude esta matriz bidimensional para uma matriz unidimensional como [1, 2, 3, 4, 5, 6], e imprima-a.
list0 =  [[1, 2], [3, 4], [5, 6]]
list1 = []
for i in list0:
  for j in i:
    list1.append(j)
print(list1, end = ' ')

# Imprima a nota média de 89,25 para as notas de Maria. Dica: Use as funções de valores() e len() do dicionário
maria = {'coreano': 94, 'ingles': 91, 'matematica': 89, 'ciencia': 83}

nota = maria.values()
soma = sum(nota)
num_curso = len(nota)
media = soma / num_curso

print("A média de Maria é:", media)

# Declarar um dicionário school, em seguida, use a função deepcopy() do módulo de copy para escrever um programa que 'copie' para outra variável, school2.

import copy
school = { 'kim': {'age': 16, 'hei': 170, 'grade': 3}, 'lee': {'age': 15, 'hei': 168, 'grade': 2}, 'choi': {'age': 14, 'hei': 173, 'grade': 1}}
school2 = copy.deepcopy(school)
print(school is school2)

# A tupla contém informações sobre quatro alunos. Nesta informação, o nome do aluno e as notas em inglês, matemática e ciências
# Extrair somente as notas matemáticas, usando a função zip na tupla da nota. Escreva um código que calcula a média das pontuações de matemáticas extraídas.

notas = (('Davi',  88,  95, 90), ('Felipe', 83, 98, 81), ('Luciano', 81, 97, 98), ('Rodrigo', 82, 89, 83))
nomes, ing, mat, cien = zip(*notas)
media = sum(mat) / len(mat)

print("A média das notas de matemática é: ", media)

"""# **CAPÍTULO 3**

## **Unidade 17: Função - FAZER**

**Missão: Criando um programa de codificação de Cifra de César**
"""

import string

def cipher(a):
  idx = src_str.index(a)
  return(dst_str[idx])

src_str = string.ascii_uppercase
dst_str = src_str[3:]+src_str[:3]
print(src_str)
print(dst_str)

src = input('Insira uma frase:') #Use letras maiusculas

print("Texto criptografado:", end ='')

for ch in src:
  if ch in src_str:
    print(cipher(ch),end ='')
  else:
    print(ch,end ='')

print()

"""**Q1: Deixe o usuário inserir três números inteiros a, b e c e imprima os valores médio, máximo e mínimo desses três números usando essas três funções: media3(a, b, c), max3(a, b, c), min3(a, b, c).  Cada uma toma três números como parâmetros e retorna os valores médio, máximo e mínimo destes três números, respectivamente. Defina e chame cada função.**"""



"""## **Unidade 18: Chamada de Função de Recursão - FAZER**

**Missão: Algoritmo do quebra-cabeça Torre de Hanói**
"""



"""**Q1: Vamos pegar um número n como entrada e encontrar a soma de 1 a n. Escreva esta função usando uma chamada recursiva de função.**"""



"""**Q2: Python tem o operador** ** **, no qual indica a elevação ao quadrado. Entretanto, vamos usar o x  e o n como entradas sem usar um operador e utilizar uma função recursiva de saída x para a enésima elevação. Vamos tentar uma saída de 2 elevado a 10, colocando o 2 como o valor de x e 10 como o valor de n, como mostra a seguir.**"""



"""**Q3: O número natural e, também chamado de número Euler ou constante de Neper, é um número irracional usado como base do logaritmo natural. Ele poder ser aproximado seguindo a fórmula.**

**(e = 1/0! + 1/1! + 1/2! + 1/3! + 1/4! + ..... + 1/n!)**

**- Para implementar essa fórmula, calcule n! com uma função denominada fatorial(n).**

**- Também defina uma função chamada euler(n) que retorna a somatória de 1/0! + 1/1! até 1/n!**

**- Para isso, use funções recursivas.**

**- Encontre o valor de euler(20) até cinco casas decimais como no exemplo de saída.**
"""



"""## **Unidade 19: Lambda - FAZER**

**Missão: Aplicar o parse a datas para comparar com o ano de publicação da série Sherlock Holmes**
"""



"""**Q1: Se você tratar as notas dos alunos nos exames de inglês, matemática e ciências como uma lista de três elementos, ela pode ser expressa como uma lista, como por exemplo [100, 90, 95].**

**- Se houver dois alunos, suas notas podem ser expressas como [100, 90, 95, 90, 85, 93], e assim por diante.**

**- Se um estudante não realizou o exame de uma determinada matéria, considere sua nota como 0.**

**- Imprima quantas notas estão contidas na lista de notas dada, o número de estudantes com notas válidas para todas as matérias (isto é, estudantes sem 0 para todas as matérias), e as notas dos estudantes com apenas notas válidas.**
"""



"""## **Unidade 20: Closure - FAZER**

**Missão: Análise da urbanização**
"""

def urban_city(city):
  global max_pop, min_pop, pop_sum
  n = 0
  for name, pop in city.items(): #Obtem o valor máximo e mínimo por iteração na declaração do loop
    if pop > max_pop:
      max_pop = pop
    if pop < min_pop:
      min_pop = pop
    pop_sum += pop
    n +=1

  print('População máxima:', max_pop)
  print('População mínima:',min_pop)
  print('Diferença entre a população máxima e mínima:',max_pop-min_pop)
  print('População média:',pop_sum/n)

#armazena dados estatíticos da população (unidade de milhares) num dicionário
max_pop = 0
min_pop = 100000
pop_sum = 0
city_pop = {'A':9765,'B':3441,'C':2954,'D':1531}
urban_city(city_pop)

"""**Q1: Obtenha a lista result a partir da lista lst, que tem valores de 1 a 100, de maneira que a result tenha apenas os elementos da lista lst que são divisíveis por 5 ou 7.**"""



"""## **Unidade 21: Classe - FAZER**

**Missão: Missão da conta bancária**
"""

class BankAccount:
#"A class model in phyton that models a bank account"

  def __init__(self,name,account_num, balance =0):
    self.name = name
    self.account_num = account_num
    self.balance = balance

  def get_name(self):
    return self.name

  def get_account(self):
    return self.account_num

  def get_balance(self):
    return self.balance

  def deposit(self,amount):
    self.balance += amount
    print("{} reais foram depositados. O saldo é de {}".format(amount,self.balance))

  def withdraw(self,amount):
    if (self.balance - amount)>0:
      self.balance = self.balance - amount
    else:
      print('O balanço da conta é de {} reais. Isto é menos do que a quantia solicitada para saque'.format(self.balance))

  def __str__(self):
    return('O saldo da conta de {} é de {} reais'.format(self.account_num,self.balance))

account1 = BankAccount('Davi','1234-0001')
print(account1)
account1.deposit(2000)
print(account1)
account1.withdraw(500)
print(account1)
account1.withdraw(5000)

"""**Q1: Construir a classe Dog e seus objetos com as funcionalidades descritas abaixo.**"""



"""**Q2: Definir a classe Dog com as funcionalidades descritas abaixo e chamar instâncias e métodos.**"""



"""**Q3: Construir classe Estudante que tenha as seguintes funcionalidades:**"""



"""## **QUIZZ - CAPÍTULO 3**"""

# Exercício 1

# Escreva um programa que recebe dois pontos no plano cartesiano, (x1, y1) e (x2, y2) e imprime a distância entre esses 2 pontos.
# d12² = (x2 – x1)² + (y2 – y1)².

import math as m

x1 = int(input("Escreva a coordenada x1 do primeiro ponto: "))
y1 = int(input("Escreva a coordenada y1 do primeiro ponto: "))
x2 = int(input("Escreva a coordenada x2 do segundo ponto: "))
y2 = int(input("Escreva a coordenada y2 do segundo ponto: "))

distancia = (((x2 - x1)**2) + ((y2 - y1)**2))**0.5

print("\nA distância entre esses dois pontos é: ", distancia)

# Exercício 2

# Um palíndromo é uma frase ou palavra que se lê da mesma forma da esquerda pra direita e vice-e-versa. Por exemplo: radar.
# Escreva um programa que usa uma função recursiva para determinar se uma string é um palíndromo ou não.

palin = str(input("Insira uma frase ou palavra: "))
palin = palin.replace(" ", "").lower()

def verificar(palin):
  if len(palin) <= 1:
    return True
  if palin[0] != palin[-1]:
    return False
  return verificar(palin[1:-1])

if verificar(palin):
    print(palin, " é um palíndromo.")
else:
    print(palin, 'não é um palíndromo.')

# Exercício 3

# Escreva um programa que usa a função map() para realizar operações de multiplicação com os itens da lista n_list = [10, 20, 30].
# O programa deve imprimir 2x e 3x os valores de n_list.

n_list = [10, 20, 30]

def mult(dois_tres, x):
    return dois_tres * x

dois_x = list(map(lambda x: mult(2, x), n_list))
print("Valores da lista x2:", dois_x)

tres_x = list(map(lambda x: mult(3, x), n_list))
print("Valores da lista x3:", tres_x)

# Exercício 4
# Considere o código a seguir e calcule o resultado do código manualmente.

def calc_digit(n):
    def final(digit):
        return digit**n
    return final
num_list = []
for num in range(1, 6):
    num_list.append(calc_digit(num))
    print(num_list[num - 1](num))

''' Obs: calc_digit(num) é chamado para cada valor de num de 1 a 5.
Para num = 1:
- calc_digit(1) retorna a função final(digit) onde final(digit) = digit**1
- num_list agora é [final] onde final(digit) = digit**1, ou seja, é 1**1, que resulta em 1 e imprime 1
Para num = 2:
- calc_digit(2) retorna a função final(digit) onde final(digit) = digit**2
- num_list agora é final(digit) = digit**2, ou seja, 2**2, que resulta em 4 e imprime 4
Para num = 3:
- calc_digit(3) retorna a função final(digit) onde final(digit) = digit**3
- num_list agora é final(digit) = digit**3, ou seja, 3**3, que resulta em 27 e imprime 27
Para num = 4:
- calc_digit(4) retorna a função final(digit) onde final(digit) = digit**4
- num_list agora é final(digit) = digit**4, ou seja, 4**4, que resulta em 256 e imprime 256
Para num = 5:
- calc_digit(5) retorna a função final(digit) onde final(digit) = digit**5
- num_list agora é final(digit) = digit**5, ou seja, 5**5, que resulta em 3125 e imprime 3125'''

# Exercício 5

# Escreva um programa que faz multiplicação (*) e divisão (/) usando os métodos __mul__ e __truediv__ aprendidos na unidade 21.
# Assumindo que v1 = (30, 40) e v2 = (10, 20), codifique (escreva a declaração de saída) para retornar a saída abaixo
# como resultado da multiplicação e divisão de dois vetores.
# v1 * v2 = (300, 800)
# v1 / v2 = (3.0, 2.0)

class Vector:
  def __init__(self, x, y):
   self.x = x
   self.y = y

  def __mul__(self, other):
    return Vector(self.x * other.x, self.y * other.y)

  def __truediv__(self, other):
    return Vector(self.x / other.x, self.y / other.y)

  def __repr__(self):
        return f"({self.x}, {self.y})"

v1 = Vector(30, 40)
v2 = Vector(10, 20)

v3 = v1.__mul__(v2)
print("Resultado da multiplicação:", v3)
v4 = v1.__truediv__(v2)
print("Resultado da divisão:", v4)

"""# **CAPÍTULO 4**

## **Unidade 22: Pilha - FAZER**

**Missão: Verificador de parênteses equilibrados**
"""

def check(expr):
  opening = '[{('
  closing = ']})'
  stack = []
  for char in expr:
    if char in opening:
      stack.append(char)
    elif char in closing:
      if len(stack)==0:
        return False
      if opening.index(stack.pop())!=closing.index(char):
        return False
  return len(stack) == 0


x = input("Input a string of parentheses:")
print("Valid" if check(x) else "Invalid")

"""**Q1: O documento HTML consiste em muitas tags, conforme mostrado abaixo. Escreva um programa que corresponda às tags de documentos HTML.**"""



"""## **Unidade 23: Fila - FAZER**

**Missão: O Problema de Josephus**
"""

def josephus(n, k):
    sequence = []
    queue = Queue()
    for i in range(1, n + 1):
        queue.enqueue(i)
    cont = 1
    while queue.size() > 1:
        if cont == k:
            sequence.append(queue.dequeue())
            cont = 1
        else:
            queue.enqueue(queue.dequeue())
            cont += 1
    return sequence, queue.dequeue()

n = int(input("Enter the number of people(N):"))
k = int(input("Entre the number to be Skipped(K):"))
seq, last = josephus(n, k)
print(f"Sequence = {seq}\nLast alive = {last}")

"""**Q1: Consulte a definição de classe a seguir para completar e testar a classe Deque.**"""



"""## **Unidade 24: Pesquisa Sequencial - FAZER**

**Missão: O problema da queda de ovos**
"""

from random import randint

def do_experiment(floor, breaking):
   return floor >= breaking

def find_highest_safe_floor(height, breaking):
  for n in range (1, height + 1):
    if do_experiment (n, breaking):
      return n - 1
  return height

height = int(input("Input the number of floors:"))
breaking = randint(1,height+1)
print(breaking)
floor =  find_highest_safe_floor(height,breaking)
print(f"The Eggs will be safe till the {floor}-th floor.")

"""**Q1: Escreva um programa para contar quantas vezes uma palavra específica foi usada na frase digitada pelo usuario.**"""



"""## **Unidade 25: Pesquisa Binária - FAZER**

**Missão: Problema da queda de ovos com ovos infinitos**
"""

def do_experiment(floor,breaking):
	return floor >= breaking

def find_highest_safe_floor2(height,breaking):
	low,high = 1, height
	while low < high:
		mid = (low+high)//2
		if do_experiment(mid,breaking):
			high=mid
		else:
			low = mid+1
	return low-1

height = int(input("Input the number of floors:"))
breaking = int(input("Input the first breaking floor:"))
floor = find_highest_safe_floor2(height,breaking)
print(f"Your egg will safe till the {floor}-th floor.")

"""**Q1: Se uma lista ordenada 'nums' e um número inteiro aleatório x forem fornecidos, implemente a função que retorna a localização do índice onde x será inserido. Porém, o S deve ser uma lista ordenada mesmo após a inserção de x.**"""



"""## **Unidade 26: Tabela Hash - FAZER**

**Missão: Conversor de números romanos**
"""

table = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
def roman_to_int(str):
    result = 0
    for i in range(len(str) - 1):
        if table[str[i]] < table[str[i + 1]]:
            result -= table[str[i]]
        else:
            result += table[str[i]]
    return result + table[str[-1]]

num = input("Input a number: ")
print(roman_to_int(num))

"""**Q1: Crie um conversor que converta algarismos arábicos em algarismos romanos usando a tabela hash fornecida abaixo.**"""



"""## **QUIZZ - CAPÍTULO 4**"""

# Exercício 1

# Escreva a saída do código a seguir

stack = Stack()
stack.push("Banana")
stack.push("Maçã")
stack.push("Tomate")
stack.pop()
stack.push("Morango")
stack.push("Uva")
stack.pop()
print(stack.stack)

# Banana, Maçã, Morango

# Exercício 2

# Escreva a saída do código a seguir

stack = Stack()
items = [10 * i for i in range(1, 10)]
for item in items:
    stack.push(item)
    if (item // 10) % 2 == 0:
        stack.pop()
print(stack.stack)

# 10, 30, 50, 70, 90

# Exercício 3

# Escreva a saída do código a seguir

queue = Queue()
items = [10 * i for i in range(1, 11)]
for item in items:
    queue.enqueue(item)
    if (item // 10) % 2 == 0:
        queue.dequeue()
print(queue.queue)

# 60, 70, 80, 90, 100

# Exercício 4

# O que o algoritmo da função find_two() abaixo faz? Analisar o código e escrever o resultado da execução.

def find_two(nums):
    x = y = 0
    for i in range(1, len(nums)):
        if nums[x] < nums[i]:
            x = i
        elif nums[y] > nums[i]:
            y = i
    return x, y
nums = [11, 37, 45, 26, 59, 28, 17, 53]
i, j = find_two(nums)
print(nums[i], nums[j])

# O algoritmo procura os índices do maior e do menor elemento em uma lista de números: maior (59), menor (11)

# Exercício 5

# Quantas comparações a função find_two() realiza na questão anterior?

# A lista nums tem 8 elementos, então a função find_two() realiza 7 comparações.

# Exercício 6

# A seguir está o código para o jogo de correspondência de números. Se o máximo é 100 e o número é 51, qual é o resultado da contagem?

maximum = int(input("Insira o valor máximo: "))
number = int(input("Insira o chute: "))
count = 0
low, high = 1, maximum
while low < high:
    mid = (low + high) // 2
    count += 1
    if mid == number:
        print(f"Seu número é {number}.")
        break
    elif mid > number:
        high = mid - 1
    else:
        low = mid + 1
print(f"Foram procuradas {count} vezes.!")

# O resultado da contagem é 6

# Exercício 7

# No código do jogo de correspondência de números, se o máximo for 100 e o número for 25, qual é o resultado da contagem?

# O resultado da contagem é 2

# Exercício 8

# Usando a função hash da classe HashTable, calcule a chave e o hashkey de "Alice no País das Maravilhas" como se segue. (O valor da chave é 1763).

table = HashTable(8)
book = "Alice no País das Maravilhas"
key = sum(map(ord, book))
print(key, table.hash(key))

# Chave: 2572, Hashkey: 4

# Exercício 9

# Se a nova estante tiver 10 compartimentos, use o seguinte código para descobrir qual livro está em cada compartimento.

table = HashTable(10)
books = [
    "O Pequeno Príncipe",
    "O Velho Homem e o Mar",
    "A Pequena Sereia",
    "A Bela e a Fera",
    "A Última Folha",
    "Alice do País das Maravilhas"
]
for book in books:
    key = sum(map(ord, book))
    table.put(key, book)
for key in table.table.keys():
    print(key, table.table[key])

'''
0 ['Alice do País das Maravilhas']
1 ['O Velho Homem e o Mar']
2 ['A Última Folha']
3 []
4 ['O Pequeno Príncipe']
5 ['A Bela e a Fera']
6 []
7 []
8 []
9 ['A Pequena Sereia']'''

"""# **CAPÍTULO 5**

## **Unidade 27: Ordenação por flutuação, seleção e inserção**

**Não teve missão!!**

**Q1: Dadas duas palavras, escreva um algoritmo que determine se essas duas strings são anagramas. Um anagrama é uma palavra formada por reordenar as letras de uma palavra diferente usando todas as letras originais exatamente uma vez. (ex. "LISTEN" (ouvir) e "SILENT" (silencioso) são anagramas no inglês).**
"""



"""**Q2: O uso de um algoritmo de classificação torna fácil determinar se é um anagrama ou não.**

**- Criar uma função que avalia os anagramas usando a função built-in sort em Python.**

**- Modificar a função selection_sort2() para criar uma função que determina os anagramas.**

**- Modificar a função insertion_sort2() para criar uma função que determine o anagrama.**
"""



"""## **Unidade 28: Ordenação por mistura**

**Missão: Fusão de duas listas ordenadas**
"""

def merge2(S, low, mid, high):
  R = []
  i, j = low, mid + 1
  while i <= mid and j <= high:
    if S[i] < S[j]:
      R.append(S[i]); i += 1
    else:
      R.append(S[j]); j += 1
  if i > mid:
    for k in range(j, high + 1):
      R.append(S[k])
  else:
    for k in range(i, mid + 1):
      R.append(S[k])
  for k in range(len(R)):
    S[low + k] = R[k]

def mergesort2(S, low, high):
  if low < high:
    mid = (low + high) // 2
    mergesort2(S, low, mid)
    mergesort2(S, mid + 1, high)
    merge2(S, low, mid, high)

S = [27, 10, 12, 20, 25, 13, 15, 22]
mergesort2(S, 0, len(S)-1)
print(S)

"""**Q1: Dadas as listas ordenadas N como entrada, escreva um programa que as funda em uma lista ordenada.**"""



"""## **Unidade 29: Ordenação por eficiência**

**Missão: Particionamento com pivô**

![image.png](data:image/png;base64,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rrjiClx++eVtBnREe5zS448/rjr/tsDveeSRRxT/2bNn+862BG2R/RHthb9DJ0VHwX0G0rt2ZctVIeLU8+ViKbcInZFCiNhjKBcpSD37gkd+D7+P9Utpb3fO+6fOP/98/OY3vwma4LBHOSV2nIwszj77bNWIGieccIIaRmCE8u2336oOlw3MTpINZaXGc4wIrArX1WCdHn300Sqq4j0BXZUpnXHGGb4z/kGuVGhmkIsWLWpy2sccc4xykuQ8f/78ptdIsF60IustHROHG3gtnVFoSKjaatAJqa38rdUAtLQXjOQefvhhnHrqqXsdAjIILjCyZ5TNAEivvBsxYgQOOuggpfvslGmndEK0Q+q31hOC+wQ/p951F6hXTz/9NI477jil//vLKbEf4kgJ7ZAcCWYsXDpP7lyuvnLlSnXeCl0//F32dQT7Mn/l7oittYXrr78ev/71rzF06NCgy5RIMughDarkD3/4A1ukSaTz94iT8ohCeaZNm9bis0CIdOqem266ySPK5St52xBH6XnllVc83333nUcc7B7fJ07J8+GHH/qu3jt2797tSUhIaPr7008/XdWPGIvnlFNOafHdgRDROY9EZx5xgB7plHylNugpoA2uXbvWM3bs2KY2PfbYYz1FRUVKzySwatHegRJxRh5xAO3WsQULFnjefvttz9atWz0SSLb4LnFKnquuuspTXl7uu7ptsC4uuOCCpr/v16+f56OPPlL1k52d7Yn1rgMPqGRkZHg+//xzVV62abBAyqawZ/4dhKADpVx77bUtHi/0r3/9Sy18YDTEewL83bu0P8Hllvfff3+bq9D8QfPxB7aVpb3aBCNEDlnoyIeZ12uvvabq5f/+7/9UPQUSHCYQA1eTrf6GfgyCG9RTDklfdtll6nmPBJ9BSTvkZ3feeSemT58e0LZlNsMFNRye6kg52rJBor02yCdccAhd2xrnj8ThqaFLzt/87Gc/a3VOen+AfdNPf/pTzJo1Sx3vjXcg0GN6BioFJzg5rs1JcoLj1kxDue7+kksuUZUdqAbnY06effbZvab4/tCWwlNp2qs47OxZHxy2o0FyyJILC/i0Cdbd3/72t4ANmXEYg0OUHFIx6JmgntIZcYL8nHPOUXrJYbrnn39eBUAc/r3nnntU5xsoXHPNNUq6uh9orw3yunPPPRc33HCDCg45TMlnBD711FNq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)
"""

from random import randint

def partition2(S, low, high):
    rand = randint(low, high)
    S[low], S[rand] = S[rand], S[low]
    pivot, left, right = S[low], low, high
    print(S, left, right, "pivot = ", pivot)

    while left < right:
        while left < high and S[left] <= pivot:
            left += 1
        while right > low and pivot <= S[right]:
            right -= 1
        if left < right:
            S[left], S[right] = S[right], S[left]

    S[low], S[right] = S[right], S[low]  # Fixed "Low" to "low"
    return right

def quicksort2(S, low, high):
    if low < high:
        pivotpoint = partition2(S, low, high)
        quicksort2(S, low, pivotpoint - 1)
        quicksort2(S, pivotpoint + 1, high)

S = [25, 22, 20, 15, 13, 12, 10]
quicksort2(S, 0, len(S) - 1)
print(S)

# Outro jeito - From: https://panda.ime.usp.br/panda/static/pythonds_pt/05-OrdenacaoBusca/OQuickSort.html
def quickSort(alist):
   quickSortHelper(alist,0,len(alist)-1)

def quickSortHelper(alist,first,last):
   if first<last:
       splitpoint = partition(alist,first,last)
       quickSortHelper(alist,first,splitpoint-1)
       quickSortHelper(alist,splitpoint+1,last)

def partition(alist,first,last):
   pivotvalue = alist[first]
   leftmark = first+1
   rightmark = last
   done = False
   while not done:
       while leftmark <= rightmark and alist[leftmark] <= pivotvalue:
           leftmark = leftmark + 1
       while alist[rightmark] >= pivotvalue and rightmark >= leftmark:
           rightmark = rightmark -1
       if rightmark < leftmark:
           done = True
       else:
           temp = alist[leftmark]
           alist[leftmark] = alist[rightmark]
           alist[rightmark] = temp

   temp = alist[first]
   alist[first] = alist[rightmark]
   alist[rightmark] = temp
   return rightmark

alist = [54,26,93,17,77,31,44,55,20]
quickSort(alist)
print(alist)

"""**Q1: Escreva um algoritmo que encontre o maior elemento Kth, dado N elementos não ordenados.**
**- Após resolver o problema com os dois métodos acima, analisar qual algoritmo é mais eficiente.**
**- Você pode retornar o elemento Kth depois de usar a função de ordenação. Você pode usar a função partition() para fazer uma chamada recursiva até que o pivô seja o elemento Kth.**
"""



"""## **QUIZZ - CAPÍTULO 5**"""

# Exercício 1
# Quantas comparações foram executadas no processo de ordenação abaixo? (Linha em negrito)

def bubblesort(S):
    n = len(S)
    comp = 0
    for i in range(n):
        print(S)
        for j in range(n-1):
            if S[j] > S[j + 1]:
                S[j], S[j + 1] = S[j + 1], S[j]
                comp += 1
    return comp

S = [50, 30, 40, 10, 20]
comp = bubblesort(S)
print(S)
print("Número de comparações:", comp)

# Resposta: 8 vezes

# Exercício 2
# Quantas comparações foram executadas no processo de ordenação abaixo? (Código em negrito)

def insertionsort2(S):
    n = len(S)
    comp = 0
    for i in range(1, n):
        print(S)
        x = S[i]
        j = i - 1
        while j >= 0 and S[j] > x:
          if S[j] > x:
            comp += 1
          S[j + 1] = S[j]
          j -= 1
        S[j + 1] = x
    return comp

S = [50, 30, 40, 10, 20]
comp = insertionsort2(S)
insertionsort2(S)
print(S)
print("Número de comparações:", comp)

# Resposta: 8 vezes

# Exercício 3
# Quantas vezes a função merge2() foi executada no processo de ordenação da fusão abaixo?

def mergesort2(S, low, high):
    if low < high:
        print(S)
        mid = (low + high) // 2
        mergesort2(S, low, mid)
        mergesort2(S, mid + 1, high)
        merge2(S, low, mid, high)

S = [6, 2, 11, 7, 5, 4, 8, 16, 10, 3]
mergesort2(S, 0, len(S) - 1)
print(S)

# Resposta: 9 vezes

# Exercício 4
# Dada a lista abaixo, escreva a saída após executar a função partition1().

def partition1(S, low, high):
    pivot = S[low]
    left, right = low + 1, high
    while left < right:
      print(S)
      while left <= right and S[left] <= pivot:
        left += 1
      while left <= right and S[right] >= pivot:
        right -= 1
      if left < right:
        S[left], S[right] = S[right], S[left]
    pivotpoint = right
    S[low], S[pivotpoint] = S[pivotpoint], S[low]
    return pivotpoint

S = [15, 10, 12, 20, 25, 13, 22]
partition1(S, 0, len(S) - 1)
print(S)

# Resposta:
# [15, 10, 12, 20, 25, 13, 22]
# [13, 10, 12, 15, 25, 20, 22]

"""# **CAPÍTULO 6**

## **Unidade 30: Algoritmo Guloso (Greedy)**

**Missão: Problema de seleção de atividades**
"""

def activity_selection1(start, finish):
  result = []
  i = 0
  result.append(i)
  for j in range (1, len(start)):
    if finish[i] <= start[j]:
      result.append(j)
      i = j
  return result

start = [1, 3, 2, 0, 5, 8, 5]
finish = [2, 4, 5, 6, 6, 9, 9]
meetings = activity_selection1(start, finish)
maximum = len(meetings)
print(meetings, maximum)

"""**Q1: Suponha que o número de moedas no problema da troca de moedas não seja infinito. Por exemplo, se você tem as seguintes moedas em sua carteira, como você deve distribuir 710 won como troco?**"""



"""**Q2: Dado o número de moedas e a quantidade de troco, encontre o número mínimo de moedas que você pode devolver como troco.**"""



"""## **Unidade 31: Dividir e Conquistar**

**Missão: Encontrando um caminho no labirinto - Caminho triangular mínimo**
"""

def find_minimum (row, col, triangle):
  if row == len(triangle):
    return 0
  else:
    minimum = min(find_minimum(row + 1, col, triangle),
                  find_minimum(row + 1, col + 1, triangle))
    return triangle[row][col] + minimum

triangle = [
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]
minimum = find_minimum(0, 0, triangle)
print("The minimum cost is ", minimum)

"""**Q1: Projetar algoritmo de dividir e conquistar que resolve o problema do Tromino.**"""



"""## **Unidade 32: Programação Dinâmica**

**Missão: O problema da sequência de Fibonacci**
"""

F = {0: 0, 1: 1}
def fib2(n):
    if n in F:
        return F[n]
    else:
       F[n] = fib2(n - 1) + fib2(n - 2)
       return F[n]

N = int(input("Entre com o valor de n: "))
print(fib2(N))

"""**Q1: Dado n inteiros em uma matriz unidimensional sucessiva, escreva um algoritmo que encontre quando a soma dos valores sucessivos na matriz for maximizada.**"""



"""## **Unidade 33: Retrocesso**

**Missão: Resolvendo o problema das oito damas através de um programa**
"""

def n_queens(i, col):
    if promising(i, col):
        if i == len (col) - 1:
            print (col)
        else:
           for j in range(len(col)):
               col[i + 1] = j
               n_queens (i + 1, col)

def promising(i, col):
    for k in range (i):
        if col[i] == col[k] or abs(col[i] - col[k]) == (i - k):
            return False
    return True

N = int(input("Input the number of queens: "))
n_queens (-1, [-1] * N)

"""**Q1: A matriz binária N*N é dada num labirinto da seguinte forma, e o ratinho deve mover-se da coordenada (0, 0) pra coordenada (N-1, N-1)**"""



"""## **QUIZZ - CAPÍTULO 6**"""

# Exercício 1
# Este é o problema da troca de moedas. Você tem uma moeda de 400 won. Escreva a saída de como o algoritmo coin_change() determina a mudança para a moeda de 800 won.

def coin_change(coins, amount):
    changes = []
    largest = 0
    while amount > 0:
        if amount < coins[largest]:
            largest += 1
        else:
            changes.append(coins[largest])
            amount -= coins[largest]
    return changes
coins = [500, 400, 100, 50, 10]
amount = int(input("Insira a quantidade: "))
changes = coin_change(coins, amount)
print(changes, len(changes))

# Resposta: Quatro moedas: 500, 100, 100, 100

# Exercício 2
# Você tem 8 moedas idênticas numeradas de 1 a 8. Destas, apenas uma moeda é mais pesada que a outra.
# Supondo que você possa pesar as moedas com uma balança equilibrada, projete um algoritmo que encontre a moeda mais pesada.
# Neste momento, quantas vezes a balança balanceada deve ser usada pelo menos?

# Resposta: Deve usar a balança pelo menos 3 vezes

def moeda_pesada(moedas):
    quant = 0
    while len(moedas) > 1:
        quant += 1
        meio = len(moedas) // 2
        esq = moedas[:meio]
        dir = moedas[meio:]
        if peso(esq, dir) == "esq":
            moedas = esq
        else:
            moedas = dir
    return moedas[0], quant

def peso(esq, dir):
    if sum(esq) > sum(dir):
        return "esq"
    elif sum(esq) < sum(dir):
        return "dir"
    else:
        return "igual"

moedas = [1, 2, 3, 4, 5, 6, 7, 8]
pesada, quant = moeda_pesada(moedas)
print("A moeda mais pesada é o número", pesada)
print("quant: ", quant)

# Exercício 3
# Há nove moedas idênticas numeradas de 1 a 9 no problema anterior. Projete um algoritmo para encontrar uma moeda pesada neste caso.
# Neste momento, quantas vezes a escala equilibrada deve ser usada pelo menos?

# Resposta: Deve usar a balança pelo menos 2 vezes, entretante para ser mais preciso, caso entre um grupo de cada para pesar com outro, seria 4 vezes

def moeda_pesada(moedas):
    quant = 0
    while len(moedas) > 1:
        quant += 1
        tres = len(moedas) // 3
        esq = moedas[:tres]
        meio = moedas[tres:2*tres]
        dir = moedas[2*tres:]
        resultado = peso(esq, meio, dir)
        if resultado == "esq":
            moedas = esq
        elif resultado == "meio":
            moedas = meio
        else:
            moedas = dir
    return moedas[0], quant

def peso(esq, meio, dir):
    if sum(esq) > sum(meio) and sum(esq) > sum(dir):
        return "esq"
    elif sum(meio) > sum(esq) and sum(meio) > sum(dir):
        return "meio"
    else:
        return "dir"

moedas = [1, 2, 3, 4, 5, 6, 7, 8, 9]
pesada, quant = moeda_pesada(moedas)
print("A moeda mais pesada é o número", pesada)
print("quant: ", quant)

# Exercício 4
# Analisar o resultado de execução do seguinte código e compará-lo com o desempenho das funções fib1(), fib2(), e fib3().

def fib4(n):
    if n <= 1:
        return n
    else:
        a, b = 0, 1
        for i in range(2, n + 1):
            a, b = b, a + b
        return b
N = int(input("Insira um número: "))
print(fib4(N))

# Resposta: A função fib4() usa uma abordagem iterativa simples para calcular a sequência de Fibonacci, sendo uma implementação mais eficiente e rápida que as outras.

# Exercício 5
# Analisar o resultado de execução do seguinte código e compará-lo com o desempenho das funções bin1() e bin2().

def bin1(n, k):
    if k == 0 or n == k:
        return 1
    else:
        return bin1(n - 1, k - 1) + bin1(n - 1, k)
n = int(input("Input the value of n: "))
k = int(input("Input the value of k: "))
print(f"binomial({n}, {k}) is {bin1(n, k)}")

def bin2(n, k):
    B= [[0] * (n + 1) for i in range (n + 1)] # Changed the inner list size to (n + 1)
    for i in range(n+1):
      for j in range(i+1):
        if j == 0 or j == i: # Changed j == 1 to j == i
          B[i][j] = 1
        else:
            B[i][j] = B[i-1][j-1] + B[i-1][j]
    return B[n][k]
n = int(input("Input the value of n: "))
k = int(input("Input the value of k: "))
print(f"binomial({n}, {k}) is {bin2(n, k)}")


def bin3(n, k):
    B = [0] * (n + 1)
    for i in range(n + 1):
        for j in range (n - 1, -1):
            if j == 0 or j == i:
                B[j] = 1
            else:
                B[j] = B[j] + B[j - 1]
    return B[k]
for i in range(10):
    for j in range(i + 1):
        print(bin3(i, j), end=' ')
    print()

# Resposta:

# Exercício 6
# Se você substituir cada letra por um número na letra seguinte, o número correspondente às cinco palavras é todo quadrado.
# Para cada palavra, a soma de cada dígito é também um número quadrado. Encontre o número representado por cada letra.

# Resposta:

"""# **CAPÍTULO 7**

## **Unidade 34: Utilizando módulos de Python**

**Missão: Criando um jogo de dados**
"""

import random
import time

def roll_dice(n):
  dice = []	# start with empty list of dice
  for i in range(n):
    dice.append(random.randint(1,6)) # add random numbers between 1 to 6 to the list
  return dice

def roll_again(choices, dice_list):
  print('Rolling again...')
  time.sleep(3)
  for i in range(len(choices)):
    if choices[i] == 'r':
      dice_list[i] = random.randint(1,6)
      time.sleep(3)

def computer_strategy1(n): #create computer choices: roll everything again
  print('Computer is thinking...')
  time.sleep(3)
  choices = ''	# start with an empty list of choices
  for i in range(n):
    if computer_rolls[i] < 5:
      choices = choices + 'r'
    else:
      choices = choices + '-'
  return choices

def computer_strategy2(n): # create computer choices: roll if < 5
  print('Computer is thinking ...')
  time.sleep(3)
  choices = ''# start with an empty list of choices
  for i in range(n):
    if computer_rolls[i] < 5:
      choices = choices + 'r'
    else:
      choices = choices + '-'
  return choices

def find_winner(cdice_list, udice_list):
  computer_total = sum(cdice_list)
  user_total = sum(udice_list)
  print('Computer total', computer_total)
  print('User total',user_total)
  if user_total > computer_total:
    print('User wins')
  elif user_total < computer_total:
    print('Computer wins')
  else:
    print('It is a tie!')

# step1 in main program area - start game
number_dice = input('Enter number of dice:')
number_dice = int(number_dice)

ready = input('Ready to start? Hit any key to continue')

# step 2 in main program area - roll dice
# User turn to roll
user_rolls = roll_dice(number_dice)
print('User first roll: ', user_rolls)

# step 3 get user choices
user_choices = input("Enter - to hold or r to roll again :")
# check length of user input

while len(user_choices) != number_dice:
	print('You must enter', number_dice,'choices')
	user_choices = input("Enter - to hold or r to all again :")

# step 4 - roll again based on user choices
roll_again (user_choices, user_rolls)
print('Player new Roll: ', user_rolls)

# passo 5-vez do computador em movimento
print('Computers turn ')
computer_rolls = roll_dice(number_dice)
print('Computer first roll: ', computer_rolls)

# step 6
# decide on what choice - using one of the strategy functions
computer_choices = computer_strategy1(number_dice)
print('Computer Choice: ', computer_choices)

# Computer rolls again using the choices it made
roll_again(computer_choices, computer_rolls)
print('Computer new Roll: ', computer_rolls)

# final line in code - deciding who wins
find_winner(computer_rolls, user_rolls)

"""**Q1: Faça um algoritmo que seleciona aleatoriamente três múltiplos de 5 do intervalo de 0 a 100 usando o módulo random e imprimi-los na forma de uma lista.**

**- Escreva todo o código e os resultados esperados de saída.**
"""



"""**Q2: Use timedelta para criar um programa que imprime o aniversário de 100 dias a partir de um dia especial seu. Não precisa ser um aniversário de 100 dias, então sinta-se à vontade para criar seu próprio calculador de aniversário especial.**

**- Escreva todo o código e os resultados esperados de saída.**
"""



"""## **Unidade 35: Série Pandas para processamento de dados**

**Missão: Densidade populacional**
"""

import numpy as np # Numpy para fazer um array durante o processamento de dados
import pandas as pd # Pandas para a criação de objetos em série
import matplotlib.pyplot as plt # Matplotlib para visualização de dados

population_2021 = {'Tokyo':37339804,
                   'Delhi': 31181376,
                   'Shangai': 27795702,
                   'Sao Paulo':22237472,
                   'Mexico City':21918936,
                   'Dhaka':21741090,
                   'Cairo': 21322750,
                   'Karashi':16459472,
                   'Istambul': 15415197,
                   'Buenos Aires': 15257673,
                   'Kinshasa': 14970460,
                   'Lagos': 14862110,
                   'Manila': 14158573,
                   'Rio de Janeiro': 13544462,
                   'Moscou': 12593252,
                   'Bogota': 11167392,
                   'Paris': 11078546,
                   'Jakarta': 10915364,
                   'Lima': 10882757}

population_2020 = {'Tokyo':37393128,
                   'Delhi': 30290936,
                   'Shangai': 27058480,
                   'Sao Paulo':22043028,
                   'Mexico City':21782378,
                   'Dhaka':21005860,
                   'Cairo': 20900604,
                   'Karashi':16093786,
                   'Istambul': 15190336,
                   'Buenos Aires': 15153729,
                   'Kinshasa': 14342439,
                   'Lagos': 14368332,
                   'Manila': 13923452,
                   'Rio de Janeiro': 13458075,
                   'Moscou': 12537954,
                   'Bogota': 10978360,
                   'Paris': 11017230,
                   'Jakarta': 10770487,
                   'Lima': 10719188}

city_area = {'Tokyo':2194,
                   'Delhi':1484,
                   'Shangai': 6340,
                   'Sao Paulo':1521,
                   'Mexico City':1485,
                   'Dhaka':306.4,
                   'Cairo': 3085,
                   'Karashi':3780,
                   'Istambul': 5343,
                   'Buenos Aires': 203,
                   'Kinshasa': 9965,
                   'Lagos': 1171,
                   'Manila': 42.88,
                   'Rio de Janeiro': 1255,
                   'Moscou': 2511,
                   'Bogota':1775 ,
                   'Paris': 105.4,
                   'Jakarta': 661.5,
                   'Lima':2672 }

# Converter cada um de três dicionários em um objeto em série.
s_2020 = pd.Series(population_2020)
s_2021 = pd.Series(population_2021)
s_area = pd.Series(city_area)

# Use duas operações aritméticas em série para calcular a flutuação da população de cada ano.
growth = s_2021-s_2020
print(growth)

# O eixo x do gráfico é a etiqueta de índice do objeto da série temporal, e o eixo y consiste em elementos de dados.
x = growth.index
y = growth.values

# figsize = (horizontal, tamanho vertical) em polegadas / se não designar o tamanho, o tamanho padrão do gráfico se torna de 6,4 e 4,8 polegadas.
plt.figure(figsize = (13,6))

# Rotation = entra em um ângulo que gira o número no sentido anti-horário / Size = tamanho da fonte
plt.xticks(rotation = 'vertical', size = 10)

# plt.barh() para traçar uma trama de barra horizontal
plt.barh(x, y)

plt.show()

# Calcular a densidade populacional
population_density = s_2020/s_area
population_density

x = population_density.index # extrai apenas os valores do índice
y = population_density.values # extrai somente os elementos de dados

plt.figure(figsize = (13,6)) # dimensão da figura (largura, altura) em polegadas

plt.xticks(rotation = 45, size = 10)

plt.barh(x, y, color = 'red') # use o parâmetro de cor para designar a cor do gráfico.

plt.title('population density', size = 15) # acrescenta o título do gráfico
plt.ylabel('city', size = 15) # acrescenta o nome do eixo x do gráfico
plt.xlabel('population', size = 15) # acrescenta o nome do eixo y do gráfico.

plt.show()

population_density.mean() # encontra o valor médio

population_density.max() # encontra o valor máximo

"""**Q1: O conjunto de dados do Spotify possui diversos valores de coluna além do nome do artista, classificação e popularidade que usamos na missão. Discuta com seu colega para criar uma playlist especial feita com outros valores de coluna.**"""



"""## **Unidade 36: Pandas DataFrame para processamento de dados**

**Missão Spotify: importando dados externos para encontrar e classificar elementos de dados desejados**
"""

# Pandas para a criação de objetos DataFrame
# Matplotlib para visualização de dados
# Seaborn, uma das ferramentas de visualização de dados

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Carregue o arquivo csv baixado para a música DataFrame.
# path = '/content/drive/MyDrive/DataSet/spotify/spotify_global_2019_most_streamed_tracks_audio_features.csv'
# path = '/content/drive/MyDrive/SIC_CP_2024/Datasets/spotify/spotify_global_2019_most_streamed_tracks_audio_features.csv'
path ='/content/drive/MyDrive/SIC_2023_01/DataSet/spotify/spotify_global_2019_most_streamed_tracks_audio_features.csv'

song = pd.read_csv(path)

# Imprima apenas 10 DataFrames na tela.
song.head(10)

# Este é um método que pode verificar o número total de DataFrames e tipos de dados do DataFrame importado.
# É um DataFrame com um total de 1717 filas e 24 colunas.
song.info()

# Um método para verificar a distribuição de dados
song.describe()

# Seleciona apenas as colunas necessárias e recria o DataFrame.
df = song[["Rank","Artist","Track Name","Artist_popularity","Streams","tempo","danceability",'energy']]
df.head()

# Criar uma nova DataFrame com um valor de 90 ou superior na coluna Artist_popularity e a canção pop_song do índice usando operadores lógicos.

pop_song =df[df["Artist_popularity"]>90]
pop_song.head()

# Quem é o artista com o maior número de músicas na lista?
rank = pop_song["Artist"].value_counts()
print(rank)

# Se você verificar o tipo de dados devolvidos, é em série.
type(rank)

# Se pop_song["Artist"].unique() for usado, todos os valores únicos não sobrepostos são encontrados na coluna DataFrame correspondente.

pop_song['Artist'].unique()

# O BTS é popular?

'BTS' in rank

# Vimos que as canções do artista correspondente existem.
# Vamos filtrar os dados para ver quantas canções e quais são as canções incluídas.

bts = pop_song[pop_song["Artist"]=="BTS"]
print(bts.shape)
print(bts)

# Vamos fazer uma lista de reprodução, fazendo uma lista separada apenas para Post Malone.

play_list = pop_song[pop_song["Artist"]=="Post Malone"]
Malone = play_list.reset_index(drop =True, inplace=False)
Malone

# Expressando o tempo por categoria como um gráfico de dispersão

x = pop_song["energy"]
y = pop_song["Rank"]
plt.scatter(x,y,color ='red',alpha=0.5)
plt.show()

# Calculando a correlação
# Método de Pearson

cor = pop_song.corr('pearson')
print(cor)

# Mapa térmico de correlação
plt.matshow(cor) # exibe os dados na forma de um mapa térmico em uma matriz.
plt.colorbar() # mostrar a barra de cores para referência.

plt.figure(figsize=(8,6))
sns.heatmap(cor,annot=True)
plt.show()

"""Para saber mais:
- [Spotify (categoria dos dados)](https://towardsdatascience.com/is-my-spotify-music-boring-an-analysis-involving-music-data-and-machine-learning-47550ae931de)
- [Análise de correlação estatística](https://analisemacro.com.br/econometria-e-machine-learning/analise-de-correlacao-em-estatistica/)
- [Tipos de correlação](https://gomesfellipe.github.io/post/2017-12-01-tipos-de-correlacoes/)
- [Grafico de dispersão](https://www.fm2s.com.br/blog/grafico-de-dispersao)
- [Mapa de calor](https://www.hotjar.com/pt-BR/mapas-de-calor/analise/)

**Q1: No conjunto de dados do Spotify, existem diversos valores de coluna além do nome do artista, classificação e popularidade que usamos em nossa missão. Discuta com seus colegas de aprendizado para criar playlists especiais usando diferentes valores de coluna.**
"""



"""## **Unidade 37: Data tidying (organização de dados)**

**Missão: Estatística descritiva e [visualização de notas](https://archive.ics.uci.edu/dataset/320/student+performance)**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# path = '/content/drive/MyDrive/DataSet/student/student-mat.csv'
# path ='/content/drive/MyDrive/SIC_CP_2024/Datasets/student/student-mat.csv'

# Passo 01
student_data = pd.read_csv(path)
print(student_data.head(), '\n')

student_data = pd.read_csv(path,sep =";")
print(student_data.head())

print(student_data.info(), '\n')

print(student_data.isnull().sum(), '\n')

print(student_data.isnull().sum().sum(), '\n')

# Passo 2
plt.hist(student_data['absences'])
plt.xlabel('absences')
plt.ylabel('count')
plt.grid(True)

plt.hist(student_data['age'])
plt.xlabel('age')
plt.ylabel('count')
plt.grid(True)

# Passo 03
student_data.describe()

# media
student_data['studytime'].mean()

# mediana
student_data['studytime'].median()

# moda
student_data['studytime'].mode()

# variancia
student_data['studytime'].var()

# desvio padrão
student_data['studytime'].std()

# visualização através do box plot
plt.boxplot(student_data['G1'])
plt.grid(True)

plt.boxplot(student_data['absences'])
plt.grid(True)

plt.boxplot([student_data['G1'],student_data['G2'],student_data['G3'],student_data['Walc'],student_data['absences']])
plt.grid(True)

# Passo 4 - coeficiente de variação
student_time_cv = student_data['studytime'].std()/student_data['studytime'].mean()
print(student_time_cv )

absences_cv = student_data['absences'].std()/student_data['absences'].mean()
print(absences_cv )

student_data.info()

df2 = student_data.select_dtypes(include=['int64'])
df2.head()

cv = df2.std()/df2.mean()
cv

# covariância
df2.cov(min_periods=None,ddof =1)

np.cov(df2['G1'],df2['G3'])

print(df2['G1'].var())
print(df2['G3'].var())

# coeficiente de correlação
df2.corr()

# gráfico de dispersão
plt.plot(df2['G1'],df2['G3'],'o')
plt.grid(True)

# Passo 5 - histograma e gráfico de dispersão das variáveis
sns.pairplot(df2[['Dalc','Walc','G1','G3']])
plt.grid(True)

"""**Q1: Depois de baixar o arquivo university_ranking.csv que está nesse diretório compartilhado e importá-lo em um data frame, verifique se há dados ausentes e decida como substituí-los ou apagá-los completamente. Os resultados do exercício devem ser organizados através de códigos reais.**"""



"""## **Unidade 38: Dados de séries temporais**

**Missão: Mercado global de frutos do mar**
"""

# Passo 1: Aquisição de dados e criação do dataframe
import pandas as pd
import numpy as np
import datetime
import matplotlib.pyplot as plt

from datetime import date, datetime, time, timezone

path = '/content/drive/MyDrive/SIC_CP_2024/Datasets/fish/capture-fisheries-vs-aquaculture.csv'
df = pd.read_csv(path)
df.head()

df.info()

# Passo 2: Pré-processamento incluindo limpeza de dados

df.drop(['Code'], axis = 1, inplace = True)
df.head()

# Pesquisar dados naN. Você pode verificar o número de dados ausentes para cada coluna
df.isnull().sum()

change_value = 0
df.fillna(change_value, inplace = True)
df.isnull().sum()

# Passo 3: Alterar o tipo de dados das séries cronológicas e substituir o índice
df['new_Year'] = pd.to_datetime(df['Year'].astype(str), format = '%Y')
df.head()

df.set_index('new_Year', inplace = True)
df.head()

df.drop(['Year'], axis = 1, inplace = True)
df.head()

df.info()

new_df = df.sort_index()
new_df.head()

new_df['Entity'] = new_df['Entity'].astype('category')
new_df.info()

new_df['Entity'].value_counts()

# Passo 4
g = new_df.groupby(['new_Year'])
g.head()

for key, group in g:
	print('+key:', key)
	print('+number:', len(group))
	print(group.head())
	print("\n")

g.head()

world_total = new_df
world_total.head()

world_total = new_df.drop(['Entity'], axis = 1)
world_total.head()

world_total_sum = world_total.sum()
world_total_sum

plt.style.use('ggplot')
world_total.plot(kind = 'area',alpha = 0.2,stacked ='false')
Tigsize = (20,10)

plt.legend()
plt.show()

# Passo 5
country = new_df['Entity'].value_counts()
print(country)
print("Data type =>", type(country))

'South Korea' in country

s = new_df.loc[new_df['Entity'] == 'South Korea']
c = new_df.loc[new_df['Entity'] =='China']
a = new_df.loc[new_df['Entity'] == 'Afghanistan']

s_y = s[['Aquaculture production (metric tons)', 'Capture fisheries production (metric tons)']]
s_x = s.index

c_y = c[['Aquaculture production (metric tons)', 'Capture fisheries production (metric tons)']]
c_x = c.index

a_y = a[['Aquaculture production (metric tons)', 'Capture fisheries production (metric tons)']]
a_x = a.index

import matplotlib.pyplot as plt
fig, axs = plt.subplots(1, 3, figsize = (15, 5))
axs[0].plot(s_x, s_y)
axs[1].plot(c_x, c_y)
axs[2].plot(a_x, a_y)

fig.suptitle('Fish Production')

"""**Q1: Discuta e pratique os dados que você praticou na seção de conceitos-chave desta palestra com seus colegas, conforme mostrado abaixo.**
**- Mude para os dados de outra empresa.**
**- Tente fatiar com base nos dados de aprendizado.**
"""



"""**Q2: Acesse a Universidade da Califórnia, Irvine, um dos conjuntos de dados abertos usados na palestra anterior, Organização de Dados de Aprendizado, e explore junto com seus colegas de aprendizado quais dados são adequados para aproveitar as vantagens da análise de dados de séries temporais.**"""



"""## **QUIZZ - CAPÍTULO 7**"""

# Exercício 1

# Converter os seguintes dados do dicionário em um objeto de dataframe usando Pandas. (O objeto dataframe é nomeado como df)

import pandas as pd
d = {'col1': [1, 2], 'col2': [3, 4], 'col3': [5, 6], 'col4': [7, 8]}
df = pd.DataFrame(d)
print(df)

# Exercício 2

# No quadro de dados criado na pergunta 1, criar um novo quadro de dados que consiste apenas de dados de coluna com o nome da coluna "col4".
# (O quadro de dados é nomeado como new_df.)

import pandas as pd
d = {'col1': [1, 2], 'col2': [3, 4], 'col3': [5, 6], 'col4': [7, 8]}
df = pd.DataFrame(d)

new_df = df[['col4']]
print(new_df)

# Exercício 3

# O índice do quadro de dados criado na Pergunta 1 é 0,1. Escreva um comando para mudar o nome destes índices para primeiro e segundo.

import pandas as pd
d = {'col1': [1, 2], 'col2': [3, 4], 'col3': [5, 6], 'col4': [7, 8]}
df = pd.DataFrame(d)

df.rename(index={0: 'primeiro', 1: 'segundo'}, inplace = True)
print(df)

# Exercício 4

# Escreva um comando para procurar por dados faltantes no quadro de dados df criado na Pergunta 1 e imprima o resultado.
# (Entretanto, os dados em falta devem ser devolvidos como Verdadeiros).

import pandas as pd
d = {'col1': [1, 2], 'col2': [3, 4], 'col3': [5, 6], 'col4': [7, 8]}
df = pd.DataFrame(d)

print(df.isnull(), '\n')
print(df.isnull().sum())

# Exercício 5

# Escreva um comando para verificar o resumo estatístico descritivo (desvio padrão, valor mínimo, modo, etc.)
# do quadro de dados df criado na Pergunta 1 e imprima o resultado.

import pandas as pd
d = {'col1': [1, 2], 'col2': [3, 4], 'col3': [5, 6], 'col4': [7, 8]}
df = pd.DataFrame(d)

print(df.describe(), '\n\n')
print(df.mean(), '\n\n') # media
print(df.median(), '\n\n') # mediana
print(df.mode(), '\n\n') # moda
print(df.var(), '\n\n') # variancia
print(df.std(), '\n\n') # desvio padrão