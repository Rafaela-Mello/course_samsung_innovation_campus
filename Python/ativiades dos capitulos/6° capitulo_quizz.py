# -*- coding: utf-8 -*-
"""CAPÍTULO 6 - QUIZZ - SIC

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1py6PntHfD6EssIzRRAqzk29GnmjYKL8M
"""

# Exercício 1
# Este é o problema da troca de moedas. Você tem uma moeda de 400 won. Escreva a saída de como o algoritmo coin_change() determina a mudança para a moeda de 800 won.

def coin_change(coins, amount):
    changes = []
    largest = 0
    while amount > 0:
        if amount < coins[largest]:
            largest += 1
        else:
            changes.append(coins[largest])
            amount -= coins[largest]
    return changes
coins = [500, 400, 100, 50, 10]
amount = int(input("Insira a quantidade: "))
changes = coin_change(coins, amount)
print(changes, len(changes))

# Resposta: Quatro moedas: 500, 100, 100, 100

# Exercício 2
# Você tem 8 moedas idênticas numeradas de 1 a 8. Destas, apenas uma moeda é mais pesada que a outra.
# Supondo que você possa pesar as moedas com uma balança equilibrada, projete um algoritmo que encontre a moeda mais pesada.
# Neste momento, quantas vezes a balança balanceada deve ser usada pelo menos?

# Resposta: Deve usar a balança pelo menos 3 vezes

def moeda_pesada(moedas):
    quant = 0
    while len(moedas) > 1:
        quant += 1
        meio = len(moedas) // 2
        esq = moedas[:meio]
        dir = moedas[meio:]
        if peso(esq, dir) == "esq":
            moedas = esq
        else:
            moedas = dir
    return moedas[0], quant

def peso(esq, dir):
    if sum(esq) > sum(dir):
        return "esq"
    elif sum(esq) < sum(dir):
        return "dir"
    else:
        return "igual"

moedas = [1, 2, 3, 4, 5, 6, 7, 8]
pesada, quant = moeda_pesada(moedas)
print("A moeda mais pesada é o número", pesada)
print("quant: ", quant)

# Exercício 3
# Há nove moedas idênticas numeradas de 1 a 9 no problema anterior. Projete um algoritmo para encontrar uma moeda pesada neste caso.
# Neste momento, quantas vezes a escala equilibrada deve ser usada pelo menos?

# Resposta: Deve usar a balança pelo menos 2 vezes, entretante para ser mais preciso, caso entre um grupo de cada para pesar com outro, seria 4 vezes

def moeda_pesada(moedas):
    quant = 0
    while len(moedas) > 1:
        quant += 1
        tres = len(moedas) // 3
        esq = moedas[:tres]
        meio = moedas[tres:2*tres]
        dir = moedas[2*tres:]
        resultado = peso(esq, meio, dir)
        if resultado == "esq":
            moedas = esq
        elif resultado == "meio":
            moedas = meio
        else:
            moedas = dir
    return moedas[0], quant

def peso(esq, meio, dir):
    if sum(esq) > sum(meio) and sum(esq) > sum(dir):
        return "esq"
    elif sum(meio) > sum(esq) and sum(meio) > sum(dir):
        return "meio"
    else:
        return "dir"

moedas = [1, 2, 3, 4, 5, 6, 7, 8, 9]
pesada, quant = moeda_pesada(moedas)
print("A moeda mais pesada é o número", pesada)
print("quant: ", quant)

# Exercício 4
# Analisar o resultado de execução do seguinte código e compará-lo com o desempenho das funções fib1(), fib2(), e fib3().

def fib4(n):
    if n <= 1:
        return n
    else:
        a, b = 0, 1
        for i in range(2, n + 1):
            a, b = b, a + b
        return b
N = int(input("Insira um número: "))
print(fib4(N))

# Resposta: A função fib4() usa uma abordagem iterativa simples para calcular a sequência de Fibonacci, sendo uma implementação mais eficiente e rápida que as outras.

# Exercício 5
# Analisar o resultado de execução do seguinte código e compará-lo com o desempenho das funções bin1() e bin2().

def bin3(n, k):
    B = [0] * (n + 1)
    for i in range(n + 1):
        for j in range (n - 1, -1):
            if j == 0 or j == i:
                B[j] = 1
            else:
                B[j] = B[j] + B[j - 1]
    return B[k]
for i in range(10):
    for j in range(i + 1):
        print(bin3(i, j), end=' ')
    print()

# Resposta: O bin3 é mais eficiente devido a sua utilização de um vetor 1D, diminuindo o tempo de uso e chamadas

# Exercício 6
# Se você substituir cada letra por um número na letra seguinte, o número correspondente às cinco palavras é todo quadrado.
# Para cada palavra, a soma de cada dígito é também um número quadrado. Encontre o número representado por cada letra.

# Resposta:

frase = "A MERRY XMAS TO ALL"
letras = frase.split()

for letra in letras:
    ascii_soma = sum(ord(x) for x in letra)
    print(f"A soma dos valores ASCII da palavra '{letra}' é: {ascii_soma}")